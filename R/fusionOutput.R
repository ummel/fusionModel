#' Generate output files resulting from fusion
#'
#' @description
#' Handles all operations needed to "do fusion" using input files generated by a successful call to \code{fusionInput}. Trains a fusion model, generates internal validation results, and then simulates multiple implicates for recipient microdata.
#'
#' @param input Character. Path to directory containing files created by \code{fusionInput}.
#' @param output Character. Optional path to directory where output files will be saved. If \code{output = NULL} (default), the output directory is automatically constructed from \code{input}.
#' @param M Integer. Desired number of fusion implicates. If \code{M = NULL} (default) it is internally set to 40 or, if \code{test_mode = TRUE}, 2 implicates.
#' @param note Character. Optional note supplied by user. Inserted in the log file for reference.
#' @param test_mode Logical. If \code{test_mode = TRUE} (default), the result files are always saved within a "/fusion_" directory in `output` (possibly created); faster hyperparameters are used for \code{\link[fusionModel]{train}}; and the internal validation step is skipped by default.
#' @param validation Logical or integer. Controls execution of internal validation (Steps 3 and 4). If `validation = 0` or `FALSE`, neither step is performed (default when `test_mode = TRUE`). If `1`, only Step 3. If `2` or `TRUE`, both Steps 3 and 4.
#' @param ncores Integer. Number of physical CPU cores used for parallel computation.
#' @param margin Numeric. Passed to same argument in \code{\link[fusionModel]{fuse}}.
#' @param ... Optional, non-default arguments passed to \code{\link[fusionModel]{train}}. For example, \code{fork = TRUE} to enable forked parallel processing.
#'
#' @details The function checks arguments and determines the file path to the appropriate `output` directory (creating it if necessary). The output files are always placed within the appropriate directory hierarchy, based on the donor and recipient information detected in the \code{input} file names. In practice, \code{output} need only be specified if working in an environment where the output files need to located somewhere different from the input files.
#'
#' The function executes the following steps:
#' 1. **Load training data inputs**. Loads donor training microdata and results of \code{\link[fusionModel]{prepXY}}.
#' 1. **Run fusionModel::train()**. Calls \code{\link[fusionModel]{train}} using sensible defaults and hyperparameters. If \code{test_mode = TRUE}, the hyperparameters are designed to do a fast/rough-and-ready model training.
#' 1. **Fuse onto training data for internal validation**. Optional step (see `validation` argument). Fuses multiple implicates to original donor training data using \code{\link[fusionModel]{fuse}}. Results saved to disk.
#' 1. **Run fusionModel::validate()**. Optional step (see `validation` argument). Passes previous step's results to \code{\link[fusionModel]{validate}}. Results saved to disk.
#' 1. **Fuse onto prediction data**. Fuses multiple implicates to supplied input prediction data using \code{\link[fusionModel]{fuse}}. Results saved to disk.
#' 1. **fusionOutput() is finished!** Upon completion, a log file named \code{"outputlog.txt"} is written to \code{output} for reference.
#'
#' @return Saves resulting `output` data files to appropriate local directory. Also saves a .txt log file alongside data files that records console output from \code{fusionOutput}.
#'
#' @examples
#' # Since 'test_mode = TRUE' by default, this will affect files in local '/fusion_' directory
#' dir <- fusionInput(donor = "RECS_2015",
#'                    recipient = "ACS_2015",
#'                    respondent = "household",
#'                    fuse = c("btung", "btuel", "cooltype"),
#'                    force = c("moneypy", "householder_race", "education", "nhsldmem", "kownrent", "recs_division"),
#'                    note = "Hello world. Reminder: running in test mode by default.")
#'
#' # List files in the /input directory
#' list.files(dir)
#'
#' # Using default settings
#' out <- fusionOutput(input = dir)
#' list.files(out)
#'
#' @export
#' @noRd

#-----

# TESTING
# input <- "fusion_/RECS/2015/2015/H/input" # The input directory
# M <- NULL
# note = NULL
# test_mode = TRUE
# validation = TRUE
# ncores = getOption("fusionData.cores")
# margin = 2
# output = "~/Desktop"

#-----

fusionOutput <- function(input,
                         output = NULL,
                         M = NULL,
                         note = NULL,
                         test_mode = TRUE,
                         validation = !test_mode,
                         ncores = getOption("fusionModel.cores"),  # For copy in fusionModel package
                         #ncores = getOption("fusionData.cores"),
                         margin = 2,
                         ...) {

  # Start time
  tstart <- Sys.time()

  # Check validity of the 'input' path
  if (!dir.exists(input)) stop("'input' directory does not exist.")
  input <- full.path(input)

  # Construct the file path 'stub' for the output files
  stub <- if (is.null(output)) {
    b <- strsplit(input, .Platform$file.sep, fixed = TRUE)[[1]]
    i <- which(b == "fusionData")
    if (length(i) == 0) {
      input
    } else {
      paste(b[1:i], collapse = .Platform$file.sep)
    }
  } else {
    if (!dir.exists(output)) stop("'output' directory does not exist.")
    full.path(output)
  }

  # Set number of implicates automatically, if not specified
  if (is.null(M)) M <- ifelse(test_mode, 2, 40)

  # Check input arguments
  stopifnot({
    M > 0 & M %% 1 == 0
    is.null(note) | is.character(note)
    is.logical(test_mode)
    is.logical(validation) | validation %in% 0:2
    ncores > 0 & ncores %% 1 == 0
    margin >= 1
  })

  # Create log file
  log.temp <- tempfile()
  log.txt <- file(log.temp, open = "wt")
  sink(log.txt, split = TRUE, type = "output")

  # Detect if 'fork = TRUE' is passed in the optional ... arguments
  # In this case, we need to turn off data.table and fst multi-threaded until after train() has executed
  temp <- list(...)
  fork <- if ("fork" %in% names(temp)) temp$fork else FALSE

  # Set cores for 'fst' and 'data.table' packages to use
  data.table::setDTthreads(ifelse(fork, 1L, ncores))
  fst::threads_fst(ifelse(fork, 1L, ncores))

  #-----

  # Report initial messages to console and log
  # The try() wrapper for fusionData is to allow case of running fusionModel::fusionOutput() on a server
  cat(format(tstart, usetz = TRUE), "\n")
  cat(R.version.string, "\n")
  cat("Platform:", R.Version()$platform, "\n")
  try(cat("fusionData v", as.character(utils::packageVersion("fusionData")), "\n", sep = ""), silent = TRUE)
  cat("fusionModel v", as.character(utils::packageVersion("fusionModel")), "\n\n", sep = "")

  # Print the original function arguments
  # Excludes 'note', if present, since it is printed separately to log, below
  print(match.call.defaults(exclude = if (is.null(note)) NULL else "note"))
  cat("\n")

  # Print message indicating 'test_mode' value
  cat("fusionOutput() is running in", ifelse(test_mode, "TEST", "PRODUCTION"), "mode.\n\n")

  # Write 'note' argument to log file (and console), if requested
  if (!is.null(note)) cat("User-supplied note:\n", note, "\n\n")

  #-----

  # Report the input files directory
  cat("The input files directory is:\n", input, "\n\n")

  # Check for presence of training dataset
  tfile <- list.files(input, "_train\\.fst$", full.names = TRUE)
  if (length(tfile) == 0) stop("Cannot locate 'train.fst' file in 'input'")
  if (length(tfile) > 1) stop("There is more than one 'train.fst' file in 'input'...")

  # Check for presence of prepXY() results
  pfile <- sub("train.fst$", "prep.rds", tfile)
  if (length(pfile) == 0) stop("Cannot locate 'prep.rds' file in 'input'")
  if (length(pfile) > 1) stop("There is more than one 'prep.rds' file in 'input'...")

  # Check for presence of ACS prediction dataset
  afile <- sub("train.fst$", "predict.fst", tfile)
  if (length(afile) == 0) stop("Cannot locate 'predict.fst' file in 'input'")
  if (length(afile) > 1) stop("There is more than one 'predict.fst' file in 'input'...")

  # Construct full output path for results files and create the directory if necessary
  dir <- dirname(file.path(stub, ifelse(test_mode, "fusion_", "fusion"), gsub("_", .Platform$file.sep, basename(tfile), fixed = TRUE)))
  dir <- file.path(dir, "output")
  cat("Result files will be saved to:\n", dir, "\n\n")
  if (dir.exists(dir)) {
    cat("The local /output directory already exists.\n")
  } else {
    dir.create(dir, recursive = TRUE)
    cat("The local /output directory was created.\n")
  }

  # Update 'stub' to include file name information
  stub <- file.path(dir, sub("train.fst", "", basename(tfile), fixed = TRUE))

  #-----

  cat("\n|=== Load training data inputs ===|\n\n")

  # Load the training data
  cat("Loading training microdata:", basename(tfile), "\n")
  train.data <- fst::read_fst(tfile)

  # Load results of prepXY() with fusion and predictor variable details
  cat("Loading prepXY() results:", basename(pfile), "\n")
  prep <- readRDS(pfile)

  #-----

  cat("\n|=== Run fusionModel::train() ===|\n\n")

  # LightGBM hyper-parameter settings
  hyper.params <- if (test_mode) {
    cat("Running in 'test' mode using fast(er) hyper-parameter settings:\n")
    list(
      boosting = "goss",
      num_leaves = 8,
      min_data_in_leaf = max(20, ceiling(nrow(train.data) * 0.01)),
      num_iterations = 50,
      bagging_fraction = 1,
      feature_fraction = 0.3,
      learning_rate = 0.2,
      max_depth = 3,
      max_bin = 16,
      min_data_in_bin = ceiling(nrow(train.data) * 0.01),
      max_cat_threshold = 8
    )
  } else {
    cat("Running in 'production' mode using standard hyper-parameter settings:\n")
    hyper.params <- list(
      boosting = "goss",
      num_leaves = 2 ^ (4:6),
      min_data_in_leaf = max(20, ceiling(nrow(train.data) * 0.001)),
      num_iterations = 2000,
      bagging_fraction = 1,
      feature_fraction = 0.8,
      learning_rate = 0.05,
      max_depth = -1,
      max_bin = 255,
      min_data_in_bin = 3,
      max_cat_threshold = 32
    )
  }
  print(hyper.params)

  # Train fusion model
  cat("Training fusion model\n")
  fsn.path <- fusionModel::train(data = train.data,
                                 y = prep$y,
                                 x = prep$x,
                                 fsn = paste0(stub, "model.fsn"),
                                 weight = "weight",
                                 nfolds = 5,
                                 nquantiles = 3,
                                 nclusters = 2000,
                                 krange = c(10, 500),
                                 hyper = hyper.params,
                                 fork = fork,
                                 cores = ncores,
                                 ...)

  # If train() was forked, reset number of threads allowed in data.table and fst
  if (fork) {
    data.table::setDTthreads(ncores)
    fst::threads_fst(ncores)
  }

  #-----

  if (validation | validation == 1) {

    cat("\n|=== Fuse onto training data for internal validation ===|\n\n")

    # Fuse multiple implicates to training data for internal validation analysis
    validfsd <- fusionModel::fuse(data = train.data,
                                  fsn = fsn.path,
                                  M = M,
                                  fsd = paste0(stub, "valid.fsd"),
                                  cores = ncores)
  }

  #-----

  if (validation | validation == 2) {
    cat("\n|=== Run fusionModel::validate() ===|\n\n")

    # Pass 'valid' implicates to validate() function
    validresults <- fusionModel::validate(observed = train.data,
                                          implicates = fusionModel::read_fsd(validfsd),
                                          subset_vars = attr(prep, "xforce"),
                                          weight = "weight",
                                          cores = ncores)

    # Save 'validation' results as .rds
    vout <- paste0(stub, "validation.rds")
    saveRDS(validresults, file = vout)
    cat("Validation results saved to:\n", vout, "\n")

  }

  #-----

  cat("\n|=== Fuse onto prediction data ===|\n\n")

  # Remove unnecessary objects in memory prior to fuse()
  suppressWarnings(rm(train.data, prep, validfsd, validresults))

  # Load the prediction data
  cat("Loading prediction microdata:", basename(afile), "\n\n")
  predict.data <- fst::read_fst(afile)

  # Fuse multiple implicates to ACS and save results to disk as compressed .csv
  cat("Fusing to ACS microdata (", M, " implicates)\n", sep = "")
  fusionModel::fuse(data = predict.data,
                    fsn = fsn.path,
                    M = M,
                    fsd = paste0(stub, "fused.fsd"),
                    cores = ncores)

  #-----

  # DEPRECATED
  # cat("\n|=== Upload /output files to Google Drive ===|\n\n")
  #
  # if (upload) {
  #   if (interactive()) {
  #     # Check if fusionData package is installed; it is necessary to call uploadFiles()
  #     fd <- !inherits(try(system.file(package='fusionData', mustWork = TRUE), silent = TRUE), "try-error")
  #     if (fd) {
  #       odf <- paste0(stub, c("model.fsn", "valid.fsd", "validation.rds", "fused.fsd"))
  #       odf <- odf[file.exists(odf)]  # Restrict to output files that exist
  #       uploadFiles(files = odf, ask = TRUE)
  #     } else {
  #       cat("fusionData package not installed; file upload skipped.\n")
  #     }
  #   } else {
  #     cat("Non-interactive session: skipping upload to Google Drive\n")
  #   }
  # } else {
  #   cat("'upload = FALSE'; file upload skipped at request of user.\n")
  # }

  #-----

  cat("\n|=== fusionOutput() is finished! ===|\n\n")

  # Report processing time
  tout <- difftime(Sys.time(), tstart)
  cat("Total processing time:", signif(as.numeric(tout), 3), attr(tout, "units"), "\n", sep = " ")

  # Finish logging and copy log file to /input
  log.path <- paste0(stub, "outputlog.txt")
  cat("\nLog file saved to:\n", log.path)
  sink(type = "output")
  close(log.txt)
  invisible(file.copy(from = log.temp, to = log.path, overwrite = TRUE))

  # Clean up and remove the temporary directory
  rm(predict.data)
  gc(verbose = FALSE)

  # Return the /output path invisibly
  return(invisible(dir))

}
