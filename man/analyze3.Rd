% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze3.R
\name{analyze3}
\alias{analyze3}
\title{Analyze fusion output to produce small area estimates}
\usage{
analyze3(analyses, implicates, by = NULL, area = NULL, cores = 1)
}
\arguments{
\item{analyses}{List. Specifies the desired analyses. See Details and Examples. Variables referenced in \code{analyses} must be in \code{implicates} or associated ACS microdata.}

\item{implicates}{Data frame or file path. Implicates of synthetic (fused) variables; typically the output from \link{fuse}. The implicates should be row-stacked and identified by integer column "M". If a file path to a ".fst" file, only the necessary columns are read into memory.}

\item{by}{Character. Optional column name(s) in \code{implicates} or \code{static} (typically factors) that collectively define the set of population subgroups for which each analysis is executed. If \code{NULL}, analysis is done for the whole sample.}

\item{area}{Specify a geographic area within which to perform the \code{analyses}. Useful for restricting the study area to a manageable size given local computing resources.}

\item{cores}{Integer. Number of cores used for multithreading in \code{\link[collapse]{collapse-package}} functions.}

\item{urbanpop}{File path to UrbanPop synthetic population data.}

\item{var_scale}{Scalar. Factor by which to scale the unadjusted replicate weight variance. This is determined by the survey design. The default (\code{var_scale = 4}) is appropriate for ACS and RECS.}
}
\value{
A tibble reporting analysis results, possibly across subgroups defined in \code{by}. The returned quantities include:

\describe{
\item{lhs}{Optional analysis name; the "left hand side" of the analysis formula.}
\item{rhs}{The "right hand side" of the analysis formula.}
\item{type}{Type of analysis: sum, mean, median, prop(ortion) or count.}
\item{level}{Factor levels for categorical analyses; NA or omitted otherwise.}
\item{est}{Point estimate; mean estimate across implicates.}
\item{moe}{Margin of error associated with the 90\% confidence interval.}
\item{rshare}{Share of MOE attributable to replicate weights (as opposed to variance across implicates).}
}
}
\description{
Calculation of point estimates and associated margin of error for small area analyses using variables fused to ACS microdata.
ORNL UrbanPop synthetic population is used to re-weight the ACS microdata for individual small areas.
Allowable small area geographic units currently limited to: block groups, Census tracts, zip codes, and counties.
Efficiently computes means, proportions, sums, counts, medians, standard deviations, and variances, optionally across population subgroups.
}
\details{
The final point estimates are the mean estimates across implicates. The final margin of error is derived from the pooled standard error across implicates, calculated using Rubin's pooling rules (1987). The within-implicate standard error's are calculated using the replicate weights and \code{var_scale}.

Each entry in the \code{analyses} list is a \code{\link[stats]{formula}} of the format \code{Z ~ F(E)}, where \code{Z} is an optional, user-friendly name for the analysis, \code{F} is an allowable “outer function”, and \code{E} is an “inner expression” containing one or more microdata variables. For example:

\code{mysum ~ mean(Var1 + Var2)}

In this case, the outer function is mean(). Allowable outer functions are: mean(), sum(), median(), sd(), and var(). When the inner expression contains more than one variable, it is first evaluated and then \code{F()} is applied to the result. In this case, an internal variable \code{X = Var1 + Var2} is generated across all observations, and then \code{mean(X)} is computed.

If no inner expression is desired, the \code{analyses} list can use the following convenient syntax to apply a single outer function to multiple variables:

\code{mean = c("Var1", "Var2")}

The inner expression can also utilize any function that takes variable names as arguments and returns a vector with the same length as the inputs. This is useful for defining complex operations in a separate function (e.g. microsimulation). For example:

\code{myfun = function(Var1, Var2) {Var1 + Var2}}

\code{mysum ~ mean(myfun(Var1, Var2))}

The use of sum() or mean() with an inner expression that returns a categorical vector automatically results in category-wise weighted counts and proportions, respectively. For example, the following analysis would fail if evaluated literally, since mean() expects numeric input but the inner expression returns character. But this is interpreted as a request to return weighted proportions for each categorical outcome.

\code{myprop ~ mean(ifelse(Var1 > 10 , 'Yes', 'No'))}

\code{analyze2()} uses "fast" versions of the allowable outer functions, as provided by \code{\link[collapse]{fast-statistical-functions}} in the \code{collapse} package. These functions are highly optimized for weighted, grouped calculations. In addition, outer functions mean(), sum(), and median() enjoy the use of platform-independent multithreading across columns when \code{cores > 1}. Analyses with numerical inner expressions are processed using a series of calls to \code{\link[collapse]{collap}} with unique observation weights. Analyses with categorical inner expressions utilize a series of calls to \code{\link[collapse]{fsum}}.
}
\examples{
# Build a fusion model using RECS microdata
fusion.vars <- c("electricity", "natural_gas", "aircon", "insulation")
predictor.vars <- names(recs)[2:12]
fsn.path <- train(data = recs, y = fusion.vars, x = predictor.vars)

# Generate 30 implicates of the 'fusion.vars' using original RECS as the recipient
recipient <- recs[c(predictor.vars, "weight", paste0("rep_", 1:96))]
sim <- fuse(data = recipient, fsn = fsn.path, M = 30)
head(sim)

#-----

# Example of custom pre-processing function
myfun <- function(v1, v2, v3) v1 + v2 + v3

# Various ways to specify analyses...
my.analyses <- list(
  # Return means for 'electricity' and proportions for 'aircon'
  mean = c("electricity", "aircon"),
  # Identical to mean = "electricity"; duplicate analyses automatically removed
  electricity ~ mean(electricity),
  # Simple addition in the inner expression
  mysum ~ sum(electricity + natural_gas),
  # Standard deviation of electricity
  sd = "electricity",
  # Unnamed analyses (no left-hand side in formula)
  ~ var(electricity + natural_gas),
  ~ mean(insulation),  # Proportions
  ~ sum(insulation),  # Counts
  # Proportions involving manipulation of >1 variable
  myprop ~ mean(aircon != "No air conditioning" & insulation < "Adequately insulated"),
  # Custom inner function
  mycustom ~ median(myfun(electricity, natural_gas, v3 = 100))
)

# Do the requested analyses, by "division"
result <- analyze2(
 analyses = my.analyses,
 implicates = sim,
 static = recipient,
 weight = "weight",
 rep_weights = paste0("rep_", 1:96),
 by = "division"
)
head(result)

#-----

# To calculate a conditional estimate, set unused/ignored observations to NA
# All outer functions execute with 'na.rm = TRUE'
# Example: mean natural_gas conditional on natural_gas > 0
# data.table::fifelse() is much faster than base::ifelse() for large data
result <- analyze2(
 analyses = ~mean(data.table::fifelse(natural_gas > 0, natural_gas, NA_real_)),
 implicates = sim,
 static = recipient,
 weight = "weight",
 rep_weights = paste0("rep_", 1:96),
 by = "division"
)
}
\references{
Rubin, D.B. (1987). \emph{Multiple imputation for nonresponse in surveys}. Hoboken, NJ: Wiley.
}
