% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/blockchain.R
\name{blockchain}
\alias{blockchain}
\title{Block and chain fusion variables}
\usage{
blockchain(data, y, x, delta = 0.01, weight = NULL, nfolds = 5, cores = 1)
}
\arguments{
\item{data}{Data frame. Donor dataset. All categorical variables should be factors and ordered whenever possible.}

\item{y}{Character or list. Variables in \code{data} to eventually fuse to a recipient dataset. If \code{y} is a list, any pre-specified blocks are preserved in the output.}

\item{x}{Character. Predictor variables in \code{data} common to donor and eventual recipient.}

\item{delta}{Numeric. Controls how aggressively variables are grouped into blocks. \code{delta = 0} results in no new blocks. See Details.}

\item{weight}{Character. Name of the observation weights column in \code{data}. If NULL (default), uniform weights are assumed.}

\item{nfolds}{Integer > 3. Number of cross-validation folds used to fit LASSO models.}

\item{cores}{Integer. Number of cores used. Only applicable on Unix systems.}
}
\description{
Given a set of prospective fusion variables, \code{blockchain()} derives a pseudo-optimal "chain" (fusion sequence/order) for the variables and (optionally) groups them into "blocks" for joint fusion of multiple variables at once. The output can be passed directly to the \code{y} argument of \code{\link{train}}.
}
\details{
The algorithm uses cross-validated LASSO models fit via \code{\link[glmnet]{glmnet}}. It first builds a "complete" model for each \code{y} using all \code{x} and other fusion variables as predictors; the cross-validated model skill is the maximum possible. Next, models are fit using only \code{x} predictors; the model skill is divided by the maximum to create a score metric. The \code{y} with the maximum score is selected as the initial fusion variable and included as a predictor in subsequent models. The remaining \code{y} are assigned to the chain in the same, greedy fashion.

When a \code{y} is selected for inclusion in the chain, its score is compared to that of the previous iteration; i.e. prior to the inclusion of the immediately preceding fusion variable. If the skill does not improve by at least \code{delta}, then the \code{y} is grouped into a block with the immediately preceding fusion variable. The logic here is that a \code{y} should follow other fusion variables if/when they add substantial explanatory power. If not, it makes sense to group the variables into a block.
}
\examples{
?recs
fusion.vars <- c("electricity", "natural_gas", "aircon")
predictor.vars <- names(recs)[2:12]
yorder <- blockchain(data = recs, y = fusion.vars, x = predictor.vars)
yorder

'y' can be a list with pre-specified blocks that are preserved in the output
fusion.vars <- list("electricity", "natural_gas", c("heating_share", "cooling_share", "other_share"))
yorder <- blockchain(data = recs, y = fusion.vars, x = predictor.vars)
yorder
}
