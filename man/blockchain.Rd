% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/blockchain.R
\name{blockchain}
\alias{blockchain}
\title{Block and chain fusion variables}
\usage{
blockchain(
  data,
  y,
  x,
  delta = 0.01,
  maxsize = 4,
  weight = NULL,
  nfolds = 10,
  fraction = 1,
  criterion = c("1se", "min"),
  cores = 1
)
}
\arguments{
\item{data}{Data frame. Donor dataset. All categorical variables should be factors and ordered whenever possible.}

\item{y}{Character or list. Variables in \code{data} to eventually fuse to a recipient dataset. If \code{y} is a list, any pre-specified blocks are preserved in the output.}

\item{x}{Character. Predictor variables in \code{data} common to donor and eventual recipient.}

\item{delta}{Numeric. Controls how aggressively variables are grouped into blocks. \code{delta = 0} results in no new blocks. See Details.}

\item{maxsize}{Integer. Maximum number of variables allowed in a block (excluding pre-specified blocks).}

\item{weight}{Character. Name of the observation weights column in \code{data}. If NULL (default), uniform weights are assumed.}

\item{nfolds}{Integer > 3. Number of cross-validation folds used to fit LASSO models.}

\item{fraction}{Numeric. Fraction of observations in \code{data} to randomly sample. For larger datasets, sampling often has minimal effect on results but speeds up computation.}

\item{criterion}{Character. Either \code{"min"} or \code{"1se"}. Determines what level of cross-validated model complexity is returned by \code{\link[glmnet]{cv.glmnet}}. All else equal, \code{criterion = "1se"} will lead to more aggressive blocking.}

\item{cores}{Integer. Number of cores used. Only applicable on Unix systems.}
}
\value{
Character vector or list giving the preferred chaining and (possibly) blocking strategy of the \code{y} variables.
}
\description{
Given a set of prospective fusion variables, \code{blockchain()} derives a pseudo-optimal "chain" (fusion sequence/order) for the variables and (optionally) groups them into "blocks" for joint fusion of multiple variables at once. The output can be passed directly to the \code{y} argument of \code{\link{train}}.
}
\details{
The algorithm uses cross-validated LASSO models fit via \href{https://cran.r-project.org/web/packages/glmnet/index.html}{glmnet}. It first builds a "complete" model for each \emph{y} (fusion) variable using \emph{all} other variables as predictors; the cross-validated model skill is the maximum possible. Next, a "minimal" model is fit using only the \emph{x} predictors; the model skill is divided by the maximum to create a "score" metric. The \emph{y} with the maximum score is assigned to the first position in the fusion chain and included as a predictor in all subsequent models. The remaining \emph{y} are assigned to the chain in the same, greedy fashion.

When a fusion variable (\emph{y1}) is selected for inclusion in the chain, its score is compared to that of the previous iteration; i.e. its score prior to including the preceding fusion variable (\emph{y0}) as a predictor. If the score does not improve by at least \code{delta}, then \emph{y1} is grouped into a block with \emph{y0}. The general logic here is that chaining makes sense if/when it adds substantial explanatory power (i.e. when \emph{y0} helps predict \emph{y1}). If chaining does not appear to do this, then the default preference is to fuse the variables jointly as a block.
}
\examples{
?recs
fusion.vars <- names(recs)[13:18]
predictor.vars <- names(recs)[2:12]
yorder <- blockchain(data = recs, y = fusion.vars, x = predictor.vars)
yorder

# 'y' can be a list with pre-specified blocks that are preserved in the output
fusion.vars <- list("electricity", "natural_gas", c("heating_share", "cooling_share", "other_share"))
yorder <- blockchain(data = recs, y = fusion.vars, x = predictor.vars)
yorder
}
