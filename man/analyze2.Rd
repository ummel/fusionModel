% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze2.R
\name{analyze2}
\alias{analyze2}
\title{Analyze fusion output}
\usage{
analyze2(
  analyses,
  implicates,
  static,
  weight,
  rep_weights,
  by = NULL,
  var_scale = 4,
  cores = 1
)
}
\arguments{
\item{analyses}{List. Specifies the desired analyses. See Details and Examples. Variables referenced in \code{analyses} must be in \code{implicates} or \code{static}.}

\item{implicates}{Data frame or file path. Implicates of synthetic (fused) variables. Typically generated by \link{fuse}. The implicates should be row-stacked and identified by integer column "M". If a file path to a ".fsd" file, only the necessary columns are read into memory.}

\item{static}{Data frame or file path. Static variables that do not vary across implicates. At a minimum, \code{static} must contain \code{weight} and \code{rep_weights}. If a file path to a ".fst" file, only the necessary columns are read into memory. Note that \code{nrow(static) = nrow(implicates) / max(implicates$M)} and the row-ordering is assumed to be consistent between \code{static} and \code{implicates}.}

\item{weight}{Character. Name of the primary observation weights column in \code{static}.}

\item{rep_weights}{Character. Vector of replicate weight columns in \code{static}.}

\item{by}{Character. Optional column name(s) in \code{implicates} or \code{static} (typically factors) that collectively define the set of population subgroups for which each analysis is executed. If \code{NULL}, analysis is done for the whole sample.}

\item{var_scale}{Scalar. Factor by which to scale the unadjusted replicate weight variance. This is determined by the survey design. The default (\code{var_scale = 4}) is appropriate for ACS and RECS.}

\item{cores}{Integer. Number of cores used for multithreading in \code{\link[collapse]{collapse-package}} functions.}
}
\value{
A tibble reporting analysis results, possibly across subgroups defined in \code{by}. The returned quantities include:

\describe{
\item{lhs}{Optional analysis name; the "left hand side" of the analysis formula.}
\item{rhs}{The "right hand side" of the analysis formula.}
\item{type}{Type of analysis: sum, mean, median, prop(ortion) or count.}
\item{level}{Factor levels for categorical analyses; NA or omitted otherwise.}
\item{est}{Point estimate; mean estimate across implicates.}
\item{moe}{Margin of error associated with the 90\% confidence interval.}
\item{rshare}{Share of MOE attributable to replicate weights (as opposed to variance across implicates).}
}
}
\description{
Calculation of point estimates and associated margin of error for analyses using fused/synthetic microdata with replicate weights. Efficiently computes means, proportions, sums, counts, medians, standard deviations, and variances, optionally across population subgroups.
This differs from \link{analyze} in that it requires replicate weights and calculates uncertainty using full replicate weight variance (no approximation).
}
\details{
The final point estimates are the mean estimates across implicates. The final margin of error is derived from the pooled standard error across implicates, calculated using Rubin's pooling rules (1987). The within-implicate standard error's are calculated using the replicate weights and \code{var_scale}.

Each entry in the \code{analyses} list is a \code{\link[stats]{formula}} of the format \code{Z ~ F(E)}, where \code{Z} is an optional, user-friendly name for the analysis, \code{F} is an allowable “outer function”, and \code{E} is an “inner expression” containing one or more microdata variables. For example:

\code{mysum ~ mean(Var1 + Var2)}

In this case, the outer function is mean(). Allowable outer functions are: mean(), sum(), median(), sd(), and var(). When the inner expression contains more than one variable, it is first evaluated and then \code{F()} is applied to the result. In this case, an internal variable \code{X = Var1 + Var2} is generated across all observations, and then \code{mean(X)} is computed.

If no inner expression is desired, the \code{analyses} list can use the following convenient syntax to apply a single outer function to multiple variables:

\code{mean = c("Var1", "Var2")}

The inner expression can also utilize any function that takes variable names as arguments and returns a vector with the same length as the inputs. This is useful for defining complex operations in a separate function (e.g. microsimulation). For example:

\code{myfun = function(Var1, Var2) {Var1 + Var2}}

\code{mysum ~ mean(myfun(Var1, Var2))}

The use of sum() or mean() with an inner expression that returns a categorical vector automatically results in category-wise weighted counts and proportions, respectively. For example, the following analysis would fail if evaluated literally, since mean() expects numeric input but the inner expression returns character. But this is interpreted as a request to return weighted proportions for each categorical outcome.

\code{myprop ~ mean(ifelse(Var1 > 10 , 'Yes', 'No'))}

\code{analyze2()} uses "fast" versions of the allowable outer functions, as provided by \code{\link[collapse]{fast-statistical-functions}} in the \code{collapse} package. These functions are highly optimized for weighted, grouped calculations. In addition, outer functions mean(), sum(), and median() enjoy the use of platform-independent multithreading across columns when \code{cores > 1}. Analyses with numerical inner expressions are processed using a series of calls to \code{\link[collapse]{collap}} with unique observation weights. Analyses with categorical inner expressions utilize a series of calls to \code{\link[collapse]{fsum}}.
}
\examples{
# Build a fusion model using RECS microdata
fusion.vars <- c("electricity", "natural_gas", "aircon", "insulation")
predictor.vars <- names(recs)[2:12]
fsn.path <- train(data = recs, y = fusion.vars, x = predictor.vars)

# Generate 30 implicates of the 'fusion.vars' using original RECS as the recipient
sim <- fuse(data = recs, fsn = fsn.path, M = 30)
head(sim)

#---------

# Example of custom pre-processing function
myfun <- function(v1, v2, v3) v1 + v2 + v3

# Various ways to specify the analyses...
analyses <- list(
  # Return means for 'electricity' and proportions for 'aircon'
  mean = c("electricity", "aircon"),
  # Identical to mean = "electricity"; duplicate analyses automatically removed
  electricity ~ mean(electricity),
  # Simple addition in the inner expression
  mysum ~ sum(electricity + natural_gas),
  # Standard deviation of electricity
  sd = "electricity",
  # Unnamed analyses (no left-hand side in formula)
  ~ var(electricity + natural_gas),
  ~ mean(insulation),  # Proportions
  ~ sum(insulation),  # Counts
  # Proportions involving manipulation of >1 variable
  myprop ~ mean(aircon != "No air conditioning" & insulation < "Adequately insulated"),
  # Custom inner function
  mycustom ~ median(myfun(electricity, natural_gas, v3 = 100))
)

# Do the requeted analyses by "division"
result <- analyze2(analyses,
                  implicates = sim,
                  static = recs,
                  weight = "weight",
                  rep_weights = paste0("rep_", 1:96),
                  by = "division")
head(result)

}
\references{
Rubin, D.B. (1987). \emph{Multiple imputation for nonresponse in surveys}. Hoboken, NJ: Wiley.
}
