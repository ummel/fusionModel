% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fuse.R
\name{fuse}
\alias{fuse}
\title{Fuse variables to a recipient dataset}
\usage{
fuse(
  data,
  file,
  k = 5,
  M = 1,
  max_dist = 0,
  idw = FALSE,
  cores = 1,
  ignore_self = FALSE,
  seed = NULL
)
}
\arguments{
\item{data}{Data frame. Recipient dataset. All categorical variables should be factors and ordered whenever possible. Data types and levels are strictly validated against predictor variables defined in \code{model}.}

\item{file}{Character. Path to fusion model file (.fsn) generated by successful call to \code{\link{train}}.}

\item{k}{Integer. Number of nearest neighbors to identify among the donor observations.}

\item{M}{Integer. Number of implicates to simulate.}

\item{max_dist}{Numeric. Controls the maximum allowable distance when identifying up to \code{k} nearest neighbors. \code{max_dist = 0} (default) means no distance restriction is applied.}

\item{idw}{Logical. Should inverse distance weighting be used when randomly selecting a donor observation from the \code{k} nearest neighbors?}

\item{cores}{Integer. Number of cores used. LightGBM prediction is parallel-enabled on all systems, but kNN is only parallel on Unix (at present).}

\item{ignore_self}{Logical. If \code{TRUE}, the kNN step excludes "self matches" (i.e. row 1 in \code{data} cannot match with row 1 in the original donor. Only useful for validation exercises. Do not use otherwise.}

\item{seed}{Set random seed if needed.}
}
\value{
For \code{fuse()}, a data frame with same number of rows as \code{data} and one column for each synthetic fusion variable. The order of the columns reflects the order in which they where fused.

If \code{M > 1}, a data frame with number of rows equal to \code{M * nrow(data)}. Integer column "M" indicates implicate assignment of each observation. Note that the ordering of recipient observations is consistent within implicates, so do not change the row order if using with \code{\link{analyze}}.
}
\description{
Fuse variables to a recipient dataset using a .fsn model produced by \code{\link{train}}. If multiple implicates are requested, output can be passed to \code{\link{analyze}}.
}
\details{
For each record in \code{data}, the predicted conditional distribution values are used to identify the \code{k} most-similar observations in the original donor data along the same dimensions. One of the \code{k} nearest neighbors is randomly selected to donate its observed/"real" response value for the fusion variable(s) in question. The random selection uses inverse distance weighting if \code{idw = TRUE}; otherwise, the donor sample weights are used.

The \code{max_dist} value is a relative scaling factor. The search radius passed to \code{\link[RANN]{nn2}} is \code{max_dist * medDist}, where \code{medDist} is the median pairwise distance calculated among all of the donor observations. This approach allows \code{max_dist} to adjust the search radius in a consistent way across all fusion variables/blocks.
}
\examples{
# Build a fusion model using RECS microdata
# Note that "test_model.fsn" will be written to working directory
?recs
fusion.vars <- c("electricity", "natural_gas", "aircon")
predictor.vars <- names(recs)[2:12]
train(data = recs, y = fusion.vars, x = predictor.vars, file = "test_model.fsn")

# Generate single implicate of synthetic 'fusion.vars',
#  using original RECS data as the recipient
recipient <- recs[predictor.vars]
sim <- fuse(data = recipient, file = "test_model.fsn")
head(sim)

# Calling fuse() again produces different results
sim <- fuse(data = recipient, file = "test_model.fsn")
head(sim)

# Generate multiple implicates
sim <- fuse(data = recipient, file = "test_model.fsn", M = 5)
head(sim)
table(sim$M)

# Test to confirm that 'ignore_self' works as intended
recs2 <- mutate(recs, electricity = jitter(electricity))
train(data = recs2, y = "electricity", x = predictor.vars, file = "test_model.fsn")

sim1 <- fuse(data = recipient, file = "test_model.fsn", ignore_self = FALSE)
sim2 <- fuse(data = recipient, file = "test_model.fsn", ignore_self = TRUE)

any(sim1 == recs2$electricity)
any(sim2 == recs2$electricity)

}
